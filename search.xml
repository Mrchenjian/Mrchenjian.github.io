<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内存使用不当</title>
    <url>/2020/03/27/JavaScript/%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93/</url>
    <content><![CDATA[<p><strong>内存查看</strong></p>
<p>浏览器： window.performance<br>node:   process.memoryUsage();</p>
<p><strong>V8内存的分配</strong></p>
<p>新生代内存空间<br>老生代内存空间</p>
<p>JavaScript回收得时候，会中断执行 jascript得设计是为了跑前端脚本-不持续，一执行就没了<br><strong>内存的大小</strong><br>和操作系统有关64位为1.4G，32位为0.7G</p>
<p>64位下新生代的空间为64MB，老生代为1400MB。</p>
<p>32位下新生代的空间为16MB，老生代为700MB</p>
<p><strong>容易引发内存使用不当的情景</strong></p>
<ul>
<li>滥用全局变量        一定要手动释放 变量=undefined</li>
<li>缓存是优化的小帮手   但是要设置 缓存索<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">15</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a.length&gt;<span class="number">4</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a.shift();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.push(<span class="keyword">new</span> <span class="built_in">Array</span>(size));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li>前端大文件上传         切片上传</li>
<li>node 端 读取  会出现内存问题   不要用readfile<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readfile()</span></pre></td></tr></table></figure>
解决方案：   创建一个 readStream  以流的形式</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>异步和js执行的步骤</title>
    <url>/2020/03/26/%E5%BC%82%E6%AD%A5/%E5%BC%82%E6%AD%A5%E5%92%8Cjs%E6%89%A7%E8%A1%8C%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p><strong>前端使用异步的场景</strong><br>1、定时任务：setTimeout，setlnverval<br>2、网络请求：ajax请求，动态加载<br>3、事件绑定</p>
<p><strong>javascrip执行顺序</strong></p>
<p>1、代码自上而下执行<br>2、逐行执行代码<br>3、有代码异步操作<br>4、异步代码插入异步队列(异步队列分：宏任务和微任务)<br>5、执行完成（查看异步队列是否为空 不为空执行异步队列）</p>
<p><strong>异步队列的执行顺序</strong><br>1、在执行下一次宏任务之前会先执行完所有微任务<br>2、只要有微任务 宏任务就会被执行<br>3、同步 =&gt; 微任务 =&gt; 宏任务</p>
<p><strong>微任务</strong> promise , process nextTick<br><strong>宏任务</strong> 整体代码 script settimeout  setInterval</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.Log(<span class="number">100</span>) </span></pre></td></tr><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">console</span>.Log(<span class="number">200</span>) </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;) </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">console</span><span class="number">.1</span>og(<span class="number">300</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 异步和单线程·执行第一行，打印100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 执行setTimeout后，传入setTimeout的函数会被暂存起来，不会立即执行（单线程的特点，不能同时干两件事）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 执行最后一行，打印300</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 待所有程序执行完，处于空闲状态时，会立马看有没有暂存起来的要执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 发现暂存起来的setTimeout中的函数无需等待时间，就立即来过来执行</span></span></pre></td></tr></table></figure>

<p><strong>同步或异步的区别是什么</strong><br>1、同步会阻塞代码执行，而异步不会<br>2、alert是同步，setTimeout是异步</p>
<p><strong>异步和单线程的关系</strong><br>js 是单线程所以 在同一时间内只能干一件事<br>异步 可以解决js 这种弊端</p>
]]></content>
      <categories>
        <category>异步</category>
      </categories>
  </entry>
  <entry>
    <title>Generator和Await</title>
    <url>/2020/03/26/%E5%BC%82%E6%AD%A5/Generator%E5%92%8CAwait/</url>
    <content><![CDATA[<h1 id="ES7中的Generator、Await"><a href="#ES7中的Generator、Await" class="headerlink" title="ES7中的Generator、Await"></a>ES7中的Generator、Await</h1><pre><code>Await 是基于Gennerator 的语法糖</code></pre><p>   Gennerator 是生成器   <code>普通函数名前 加*  叫生成器函数</code></p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">console</span><span class="number">.1</span>og(<span class="number">1</span>)；</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="number">1</span>;<span class="comment">//=&gt;每一个yield控制一个状态节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="number">2</span>； yield3；</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> inter=gen()； </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(inter.next())；(value:<span class="number">1</span>,<span class="attr">done</span>:<span class="literal">false</span>) </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(inter.next())；</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//&#123;value:2,done:false&#125; console.log(inter.next())；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//&#123;value:3,done:fasle&#125; console.log(inter.next())；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//&#123;value:undefined,done:true)</span></span></pre></td></tr></table></figure></code></pre><p>  <strong>await</strong></p>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yieldPromise</span> (<span class="params">generator</span>) </span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">Let interator = generator();</span></pre></td></tr><tr><td class="code"><pre><span class="line">recursFunc.call(interator); </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursFunc</span> (<span class="params">value</span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> interator = <span class="keyword">this</span>，</span></pre></td></tr><tr><td class="code"><pre><span class="line">result = interator.next(value) ; </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(result.done) <span class="keyword">return</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve (result,value).then(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  value=&gt;&#123;recursFunc.call(interator, value)  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">yieldPromise(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">Let vI = yfeld <span class="built_in">Promise</span>.resolve(<span class="number">100</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>. Log(v1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> V2 = yteLd <span class="built_in">Promise</span>.resolve(<span class="number">200</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>. Log(v2); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure></code></pre><p>   Generator函数执行：不会让的数立即执行，返回结果是Interator选代器（ES6:for of循环）</p>
<pre><code>yield本身没有返回值，或者说返回值为undefined，next方法带参数，
参数会被当作上一条vield返回值，所以第一个yield的返回值一直是undefined

第一次 不能赋值</code></pre>]]></content>
      <categories>
        <category>异步</category>
      </categories>
  </entry>
  <entry>
    <title>原型链</title>
    <url>/2020/03/26/js%E9%AB%98%E7%BA%A7/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="原型规则和示例"><a href="#原型规则和示例" class="headerlink" title="原型规则和示例"></a>原型规则和示例</h2><p>1、所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”意外）<br>2、所有的引用类型（数组、对象、函数），都有一个proto属性，属性值是一个普通的对象<br>3、所有的函数，都有一个prototype属性，属性值也是一个普通的对象 箭头函数没有<br>4、所有的引用类型（数组、对象、函数），<strong>proto</strong>属性值指向它的构造函数的”prototype、“属性值<br>5、当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<em>_proto</em>(即它的构造函数的prototype)中寻找。</p>
<p><strong>instanceof原理</strong><br>instanceof Foo的判断逻辑是：<br>f的_proto_一层一层往上，能否对应到Foo.prototype<br>再试着判断 f instanceof Object</p>
<p>所有的引用类型都可以扩展属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span></pre></td></tr><tr><td class="code"><pre><span class="line">arr.a=<span class="number">100</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">arr.b=<span class="number">200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">arr[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="attr">a</span>:<span class="number">100</span>,<span class="attr">b</span>:<span class="number">200</span>] </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">fn.a=<span class="number">100</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> fn.b=<span class="number">200</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> obj=&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     a: <span class="number">100</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">     b: <span class="number">200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">obj.proto===<span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js高级</category>
      </categories>
  </entry>
  <entry>
    <title>JS 数据类型底层原理</title>
    <url>/2020/03/26/JavaScript/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><h2 id="tyoeof-nul-底层原理："><a href="#tyoeof-nul-底层原理：" class="headerlink" title="tyoeof nul  底层原理："></a>tyoeof nul  底层原理：</h2><div style="text-align=center">
    对象在计算机的存储 用二进制表示的，在javaScipt中如果二进制的前三位能为0，系统会判定为是object类型，null的存储二进制是000，

<pre><code>000  对类型
111  整型
100  字符串
110  布尔声应</code></pre><p>if(![]==true)</p>
<p>if([]==true)  </p>
<p>都正确   取反是对地址取反</p>
<h2 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h2><p>  JS中的相等比较==/==<br>  == 在比较的时候可以转换左右两边相等的数据类型<br>  对象对象   比较地址，<br>  对象=字符串  对象变为字符串<br>  NaN==NaN NaN和自己以及其它值都不相等<br>  null==undefined 他两个在两个等于号下相等，三个等于号下不相等，并且和其它值都不相<br>   <code>剩下的下的情况，只要两边类型不同，最后都转接为数字</code><br> []==false 比较<br> 对象.toString（）待及object.prototype.tostring.call（)<br> object.is（）相对于==/===的比较有哪些好处 深度比较：=》深度克隆</p>
</div></blockquote>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Promise 进阶</title>
    <url>/2019/03/26/%E5%BC%82%E6%AD%A5/Promiss%20%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="Promiss-进阶"><a href="#Promiss-进阶" class="headerlink" title="Promiss 进阶"></a>Promiss 进阶</h1><h2 id="Promiss-all"><a href="#Promiss-all" class="headerlink" title="Promiss.all()"></a>Promiss.all()</h2><p><strong>功能：</strong> 批量执行</p>
<p><strong>用法</strong>：1、Promise.all([p1,p2,p3…J])用于将多个Promise实例，包装成一个新的promiss实例</p>
<p>2、它接受一个数组作为参数。 </p>
<p>3、数组里可以是Promise对象，也可以是别的值，只有Promise会等待状态改变。</p>
<p>4、当所有子Promise都完成，该Promise完成，返回值是全部值的数组</p>
<p>5、有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 使用<span class="string">`Promise.all()`</span>包装多个<span class="built_in">Promise</span>实例</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'here we go'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">all</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1：'</span>, all);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all([ <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ooxx'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;, <span class="string">'xxoo'</span>, <span class="literal">false</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">all</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2：'</span>, all);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                resolve(<span class="string">'I\'m P1'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;, <span class="number">1500</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                resolve(<span class="string">'I\'m P2'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;, <span class="number">1000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                resolve(<span class="string">'I\'m P3'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;, <span class="number">3000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all([p1, p2, p3]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">all</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'all'</span>, all);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .catch( <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Catch：'</span>, err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr></table></figure>



<h2 id="Promise-all-最常见就是和-map-连用。"><a href="#Promise-all-最常见就是和-map-连用。" class="headerlink" title="Promise.all 最常见就是和.map()连用。"></a>Promise.all 最常见就是和.map()连用。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历目录，找出最大的一个文件-通过Promise.all()和.map()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.imooc.com/video/16622</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FileSystem = <span class="built_in">require</span>(<span class="string">'./FileSystem'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLargest</span>(<span class="params">dir</span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> FileSystem.readDir(dir, <span class="string">'utf-8'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .then( <span class="function"><span class="params">files</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.all( files.map( <span class="function"><span class="params">file</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    fs.stat(path.join(dir, file), (err, stat) =&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">if</span> (stat.isDirectory()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">return</span> resolve(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                size: <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        stat.file = file;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        resolve(stat);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .then( <span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">let</span> biggest = stats.reduce( <span class="function">(<span class="params">memo, stat</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(memo.size &lt; stat.size) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> stat;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> memo;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> biggest.file;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="Promiss-resolve"><a href="#Promiss-resolve" class="headerlink" title="Promiss.resolve()"></a>Promiss.resolve()</h2><p><strong>返回值：</strong>返回一个fulfilled的Promise实例，或原始Promise实例。</p>
<p><strong>参数：</strong> 1、参数为空，返回一个状态为fulfilled的Promise 实例</p>
<p>2、参数是一个跟Promise无关的值，同上，不过fulfuilled响应函数会得到这个参数</p>
<p>3、参数为Promise实例，则返回该实例，不做任何修改</p>
<p>4、参数为thenable，立刻执行它的.then0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise.resolve()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.imooc.com/video/16625</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Step 1'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(value, <span class="string">'World'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                resolve(<span class="string">'Good'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;, <span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(value, <span class="string">' evening'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            then() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">console</span>.log(<span class="string">', everyone'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr></table></figure>



<h2 id="Promiss-reject"><a href="#Promiss-reject" class="headerlink" title="Promiss.reject()"></a>Promiss.reject()</h2><p><strong>返回值：</strong> 返回一个rejected的Promise实例。</p>
<p>Promise.reject)不认thenable</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">'something wrong'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">promise</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'it\'s ok'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .catch( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'no, it\'s not ok'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            then() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">console</span>.log(<span class="string">'it will be ok'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">catch</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">console</span>.log(<span class="string">'not yet'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr></table></figure>

<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>类似Promise.all()，区别在于它有任意一个完成就算完成。</p>
<p>   <strong>常见用法：</strong>  把异步操作和定时器放在一起  如果定时器先触发，就认为超时，告知用户</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这是一个长时间的调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        resolve(<span class="string">'I\'m P1'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;, <span class="number">10000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这是个稍短的调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        resolve(<span class="string">'I\'m P2'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;, <span class="number">2000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([p1, p2])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr></table></figure>



<h2 id="把回调包装成-Promise"><a href="#把回调包装成-Promise" class="headerlink" title="把回调包装成 Promise"></a>把回调包装成 Promise</h2><p>把回调包装成Promise最为常见。它有两个显而易见的好处</p>
<ul>
<li><p>可读性更好</p>
</li>
<li><p>返回的结果可以加入任何Promise队列</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'./FileSystem'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'../README.md'</span>, <span class="string">'utf-8'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then(<span class="function"><span class="params">content</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(content);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr></table></figure>

<h2 id="把任何异步操作包装成Promise"><a href="#把任何异步操作包装成Promise" class="headerlink" title="把任何异步操作包装成Promise"></a>把任何异步操作包装成Promise</h2><p><strong>假设需求：</strong></p>
<p>1、用户点击按钮，弹出确认窗体。</p>
<p>2、用户确认和取消有不同的处理。<br>3、样式问题不能使用window.confirm0</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 弹出窗体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> confirm = popupManager.confirm(<span class="string">'您确定么？'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">confirm.promise</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// do confirm staff</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// do cancel staff</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 窗体的构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Confirm</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">constructor</span>() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.confirmButton.onClick = resolve;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">this</span>.cancelButton.onClick = reject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h2><p>有时候我们不希望所有动作一起发生，而是按照一定顺序，逐个进行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise=doSomething()；</span></pre></td></tr><tr><td class="code"><pre><span class="line">promise=promise.then(doSomethingElse)；</span></pre></td></tr><tr><td class="code"><pre><span class="line">promise=promise.then(doSomethingElse2)；</span></pre></td></tr><tr><td class="code"><pre><span class="line">promise=promise.then(doSomethingElse3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用 forEach 实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 易错  没有把.then0产生的新Promise 实例赋给 promise，没有生成队列。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">things</span>)</span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">1</span>et promise=<span class="built_in">Promise</span>.resolve()； </span></pre></td></tr><tr><td class="code"><pre><span class="line">    things.forEach( </span></pre></td></tr><tr><td class="code"><pre><span class="line">        thing=&gt;&#123; promise=promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                doThing(thing，（）=&gt;&#123; resolve()；</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                &#125;）； </span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;）； </span></pre></td></tr><tr><td class="code"><pre><span class="line">                               &#125;）；</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                      &#125;）；</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> promise；</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用.reduce()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//易错 Promise 实例创建之后，会立刻运行执行器代码，所以这个也无法达成队列的效果。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queue</span>(<span class="params">things</span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> things.reduce(<span class="function">(<span class="params">promise,thing</span>)=&gt;</span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="params">resolve</span>=&gt;</span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                doThing(thing,()=&gt;&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    resolve()； </span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;）； </span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;）；</span></pre></td></tr><tr><td class="code"><pre><span class="line">                               &#125;）；</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            &#125;，<span class="built_in">Promise</span>.resolve())；</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">queue([<span class="string">'lots'</span>,<span class="string">'of'</span>,<span class="string">'things'</span>,..J)；</span></pre></td></tr></table></figure>





<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>jQuery 已经实现了Promise。</p>
<p>如果你需要在IE中使用Promise，有两个选择：</p>
<ul>
<li><p>只想实现异步队列：jQuery.defered</p>
</li>
<li><p>需要兼容所有平台：Bluebird Promise polyfill</p>
</li>
</ul>
<h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>Fetch API是XMLHttpRequest的现代化替代方案</p>
<ul>
<li>更强大，也更友好。</li>
<li>直接返回一个Promise实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'some.json'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> response.json();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .then( <span class="function"><span class="params">json</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// do something with the json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    .catch( <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(err);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr></table></figure>

<h2 id="异步函数-async-await"><a href="#异步函数-async-await" class="headerlink" title="异步函数 async/await"></a>异步函数 async/await</h2><ul>
<li>赋予JavaScript以顺序手法编写异步脚本的能力</li>
<li>既保留异步运算的无阻塞特性，还继续使用同步写法。</li>
</ul>
<p><strong>那我为啥还要学Promise?</strong></p>
<p>async/await 仍然需要 Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">x</span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            resolve(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;, <span class="number">2000</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> x = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">10</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">f1();</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>异步</category>
      </categories>
  </entry>
  <entry>
    <title>javascript内存回收机制</title>
    <url>/2019/03/09/JavaScript/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="js垃圾回收"><a href="#js垃圾回收" class="headerlink" title="js垃圾回收"></a>js垃圾回收</h2><p>JavaScript有自动垃圾回收机制，也就是说执行环境会负责管理代码执行过程中使用的内存，在开发过程中就无需考虑内存分配及无用内存的回收问题了</p>
<h2 id="变量生命周期"><a href="#变量生命周期" class="headerlink" title="变量生命周期"></a>变量生命周期</h2><p>变量分为： 局部变量和全局变量<br>局部变量：函数执行完释放  全局变量等程序执行完释放</p>
<h2 id="标记方式"><a href="#标记方式" class="headerlink" title="标记方式"></a>标记方式</h2><p> <strong>标记清除 （谷歌）</strong></p>
<p> 这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。<br>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间</p>
<p>1、在js中，全局变量和window对象会一直存在，不会被回收<br>2、递归所用到的所有方法和变量，不会被回收<br>3、闭包里用到的变量，不会被回收<br>4、所有被标记的，都被认为是垃圾，会启动其回收机制，释放内存<br>5、栈内存释放  函数执行完 ，形成的执行上下文中  没有东西被上下文以外的东西占用  此上下文就会执行环境栈中移除（释放）如果有被占用，则压缩到栈的底部 （没有释放  =》闭包）<br>6、对象等于 null   就没有人占用它 就会回收 堆内存释放  变量 = null</p>
<p><strong>引用计数 （IE）</strong></p>
<p>弊端：  很多情况下  会导致记录的数字不是很准确 导致很多应该被清除的内存， 没有被清除掉  =&gt; 内存泄漏）</p>
<p>　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存</p>
<p>但是用这种方法存在着一个问题，下面来看看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    objA.someOtherObject = objB;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    objB.anotherObject = objA;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>
<p>　　我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object<br>Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使IE的Javascript引擎使用标记清除的策略来实现的，但JavaScript访问的COM对象依然是基于引用计数的策略的。说白了，只要IE中涉及COM对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"some_element"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj =<span class="keyword">new</span> <span class="built_in">Object</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">myObj.element = element;</span></pre></td></tr><tr><td class="code"><pre><span class="line">element.someObject = myObj;</span></pre></td></tr></table></figure>
<p>上面这个例子中，在一个DOM元素(element)与一个原生JavaScript对象(myObj)之间建立了循环引用。其中，变量myObj有一个名为element的属性指向element；而变量element有一个名为someObject的属性回指到myObj。由于循环引用，即使将例子中的DOM从页面中移除，内存也永远不会回收。</p>
<p>　　不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。</p>
<p>myObj.element = null;<br>element.someObject =null;<br>　　这样写代码的话就可以解决循环引用的问题了，也就防止了内存泄露的问题。</p>
<h2 id="减少JavaScript中的垃圾回收"><a href="#减少JavaScript中的垃圾回收" class="headerlink" title="减少JavaScript中的垃圾回收"></a>减少JavaScript中的垃圾回收</h2><p>　　首先，最明显的，new关键字就意味着一次内存分配，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。</p>
<p>另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：</p>
<p>{} （创建一个新对象）<br>[] （创建一个新数组）<br>function() {…} (创建一个新的方法，注意：新建方法也会导致垃圾收集！！)<br>1、对象object优化<br>　　为了最大限度的实现对象的重用，应该像避使用new语句一样避免使用{}来新建对象。</p>
<p>　　{“foo”:”bar”}这种方式新建的带属性的对象，常常作为方法的返回值来使用，可是这将会导致过多的内存创建，因此最好的解决办法是：每一次函数调用完成之后，将需要返回的数据放入一个全局的对象中，并返回此全局对象。如果使用这种方式，就意味着每一次方法调用都会导致全局对象内容的修改，这有可能会导致错误的发生。因此，一定要对此全局对象的使用进行详细的注释和说明。</p>
<p>　　有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。</p>
<p>　　cr.wipe(obj)方法就是为此功能而生，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cr.wipe = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span> (obj.hasOwnProperty(p))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">delete</span> obj[p];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！<br>2、数组array优化<br>　　将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p>
<p>3、方法function优化<br>　　方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。</p>
<p>　　在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">self</span>) </span>&#123;                    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              self.tick();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;)(<span class="keyword">this</span>), <span class="number">16</span>)</span></pre></td></tr></table></figure>
<p>　每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！</p>
<p>　　为了解决这个问题，可以将作为返回值的方法保存起来，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// at startup</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.tickFunc = (</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">self</span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                self.tick();</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">)(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// in the tick() function</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">setTimeout(<span class="keyword">this</span>.tickFunc, <span class="number">16</span>);</span></pre></td></tr></table></figure>

<p>相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。</p>
<p>4、高级技术<br>　　从根本上来说，javascript本身就是围绕着垃圾收集来设计的。随着我们工作的进行，避免内存垃圾变得越来越困难。因为很多方便实用的Javascript库方法也会产生一些新的对象。对于这些库方法产生的垃圾，我们束手无策，只能重新翻看文档，并且检查方法的返回值。例如，数组的slice方法返回一个新的数组（在不修改原数组的基础上，截取出一部分作为新数组），字符串的substr方法返回一个新的字符串（在不修改原字符串的基础上，截取出一部分字符串作为返回值）等等。</p>
<p>　　调用这些库方法，将会创建内存垃圾，而你能做的，只有避免调用这些方法，或者用不创建系统垃圾的方式重写这些方法（有点极端啦~）。</p>
<p>　　例如，在Construct2引擎中，从数组中利用下标来删除一个元素，是经常进行的操作。最初我们是用下面这种方式来实现的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sliced = arr.slice(index + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">arr.length = index;</span></pre></td></tr><tr><td class="code"><pre><span class="line">arr.push.apply(arr, sliced);</span></pre></td></tr></table></figure>
<p>　然而，slice方法会返回一个新的数组对象（数组中的元素是原数组中删掉的部分），并且会通过arr.push.apply方法将元素重新复制回原数组，但是在此操作之后，该数组就成为了一片内存垃圾。由于这是我们引擎中的垃圾产生的热点代码（使用频率非常很高），因此我们利用了迭代的方式重写了上述代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = index, len = arr.length – <span class="number">1</span>; i &lt; len; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arr[i] = arr[i + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">arr.length = len;</span></pre></td></tr></table></figure>
<p>显然，重写大量的库函数是非常痛苦的，因此你必须仔细权衡方法的易用性和内存垃圾产生情况。如果产生大量内存垃圾的方法在动画的每一帧中被多次调用，你可能就会兴高采烈的重写库函数啦。</p>
<p>　　在递归函数中，通过{}构造空对象，并在递归过程中传递数据，虽然是很方便的。但是更好的方式是：利用一个单独的数组对象作为堆栈，在递归过程中对数组进行push和pop操作。更进一步，不要调用array的pop方法（pop将会使得array的最后一个元素将会变成内存垃圾），而应该使用一个索引来记录数组的最后一个元素的位置，在pop时简单的将索引减一即可；类似的，将索引加1来代替array的push操作，只有当索引对应的元素不存在时，才执行真正的push为数组加入一个新元素。</p>
<p>　　另外，在任何时候，都应该避免使用向量对象（例如：包含x和y属性的vector2对象）。有些方法将向量对象作为方法返回值，既可以支持返回值的再次修改，又能够将需要的属性一次性返回，使用起来非常方便。但是有时候在一帧动画中，创建了成百上千个这样的向量对象，从而导致严重的垃圾回收性能问题，也是非常常见的。因此最好将这些方法分离成具有独立职责的功能个体，例如：利用getX()和getY()方法（返回具体数据）代替getPosition()方法（返回一个vector2对象）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　在Javascript中，彻底避免垃圾回收是非常困难的。垃圾回收机制与实时软件（例如：游戏）的实时性要求，从根本上就是对立的。</p>
<p>　　但是，为了减少内存垃圾，我们还是可以对javascript代码进行彻底检查，有些代码中存在明显的产生过多内存垃圾的问题代码，这些正是我们需要检查并且完善的。</p>
<p>　　我认为，只要我们投入更多的精力和关注，实现实时的、低垃圾收集的javascript应用还是很有可能的。毕竟，对于可交互性要求较高的游戏或应用来说，实时性和低垃圾收集，两者都是至关重要。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js回收机制</tag>
      </tags>
  </entry>
</search>
